[equations]

# Static AEB system - no time evolution, just instantaneous decision making

# Input conditions (from sensors/context)
dist = dist_u          # Current distance to obstacle (meters)
vel = vel_u            # Current vehicle velocity (m/s)
radar_conf = radar_conf_u  # Radar detection confidence (0-1)

# AEB system decision logic
# Critical distance threshold based on velocity (stopping distance estimation)
# Assumes ~0.8s reaction time + braking distance at 8 m/s^2 deceleration
critical_dist = vel * 0.8 + (vel * vel) / (2 * 8.0)

# Distance margin - how close we are to critical distance
dist_margin = dist - critical_dist

# AEB trigger decision: activate if distance margin is negative AND radar confidence is high
# Uses smooth activation function instead of hard threshold
aeb_should_trigger = min(1, max(0, (-dist_margin) * radar_conf))

# Braking force applied (0-1, where 1 is maximum braking)
brake_force = aeb_should_trigger

# Collision risk assessment
# High risk if we're within critical distance with high confidence
collision_risk = min(1, max(0, (critical_dist - dist) / critical_dist * radar_conf))

# Collision occurs if distance is very small (< 2m) regardless of other factors
collision = min(1, max(0, (2 - dist) / 2))

# Collision severity based on velocity and distance
# Higher velocity and closer distance = higher severity
collision_severity = min(1, (vel / 20.0) * max(0, (5 - dist) / 5))

[domains]
# Current distance to obstacle (meters)
dist_u: Float(1.0, 50.0)

# Current velocity (m/s, roughly 0-72 km/h)
vel_u: Float(2.0, 20.0)

# Radar confidence (0 = no detection, 1 = perfect detection)
radar_conf_u: Float(0.0, 1.0)

# All computed variables
dist, vel, radar_conf: Float(0.0, 100.0)
critical_dist, dist_margin: Float(-50.0, 100.0)
aeb_should_trigger, brake_force: Float(0.0, 1.0)
collision_risk, collision, collision_severity: Float(0.0, 1.0)
